<!DOCTYPE HTML><html lang="en"><head>
<meta charset="UTF-8">
<title>GMLive.gml cheat sheet</title>
<meta name="viewport" content="width=device-width" />
<meta name="livenode" content="#doc" />
<meta property="theme-color" content="#FFF037" />
<meta property="og:type" content="article" />
<meta property="og:locale" content="en_us" />
<meta property="og:site_name" content="YellowAfterlife" />
<meta property="og:title" content="GMLive.gml cheat sheet" />
<script type="text/javascript">
if (document.location.host == "yal.cc" && location.protocol == "http:") {
	document.location.protocol = "https:";
}
</script>
<style type="text/css">body, #doc tt, #doc code {
	font: 15px 'Open Sans', sans-serif;
	line-height: 1.35;
}
body {
	margin: 0;
}
.main {
	width: 100%;
	min-height: 100%;
	min-height: 100vh;
	background-color: #f5f7f9;
}
.page {
	max-width: 656px;
	background: #ffffff;
	margin: 0 auto;
	padding: 8px;
	box-shadow: 0 0 8px rgba(0, 0, 0, 0.1);
	min-height: 100%;
	min-height: 100vh;
	box-sizing: border-box;
}
.page > p:first-child {
	margin-top: 0;
}
#doc, #doc ul, #doc ol {
	padding-left: 0;
	margin: 0;
}
#doc blockquote { margin: 0.5em 0; padding: 0; }
#doc article > ul, #doc li > ul,
#doc article > ol, #doc li > ol {
	padding-left: 20px;
}
#doc article ul li {
	list-style: disc;
	list-style-image: url('data:image/svg+xml;base256,<?xml version="1.0" encoding="UTF-8"?><svg xmlns="http://www.w3.org/2000/svg" width="20px" height="1em" viewBox="0 0 20px 1em"><circle cx="17px" cy="0.675em" r="2px"/></svg>'); 
}

#doc header {
	margin: 0;
	font-weight: 700;
	font-size: 100%;
	color: #458;
	border-left: 2px solid #f3f3f3;/* #f9f9f9*/
	padding-left: 4px;
	padding-top: 1px;
	padding-bottom: 1px;
	cursor: pointer;
	display: flex;
	align-items: center;
}
#doc header a {
	outline: none;
	text-decoration: none;
	color: #458;
	word-break: break-word;
}
#doc header::before {
	display: inline-block;
	content: "+";
	font: 12px monospace;
	border: 1px solid #458;
	line-height: 11px;
	height: 11px;
	width: 11px;
	text-align: center;
	border-radius: 50%;
	margin-right: 4px;
	vertical-align: middle;
	flex-shrink: 0;
}
#doc section.open > header::before {
	content: "-";
}
#doc section.empty > header::before {
	content: " "; /*"Â·"*/
}

#doc header:hover,
#doc .sticky-side:hover {
	border-left-color: #E7E7E7; /* rgba(0, 0, 0, 0.05) */
	background: rgba(0, 0, 0, 0.048);
}
#doc header .ret-arrow {
	font-weight: normal;
	margin: 0 0.1em;
}

#doc a.broken {
	color: red;
}
#doc p, .intro p {
	margin: 0;
}
#doc p + p, .intro p + p, #doc p.pad, .display-controls {
	margin-top: 0.5em;
}
#doc img {
	max-width: 100%;
}
#doc h3 {
	margin: 0.25em 0;
	font-size: 125%;
	font-weight: normal;
	border-bottom: 1px solid #ccc;
}

#doc article,
#doc ul,
#doc ol,
#doc blockquote {
	padding-left: 20px;
	border-left: 2px solid #f3f3f3;
}
#doc article {
	padding-top: 0.25em;
	padding-bottom: 0.5em;
	position: relative;
}
#doc .sticky-side {
	position: absolute;
	left: -2px;
	top: 0;
	bottom: 1px;
	width: 20px;
	writing-mode: vertical-rl;
	font-size: 85%;
	text-orientation: sideways;
	/*transform: rotate(0.05deg);*/
}
#doc .sticky-side,
#doc .sticky-side:visited {
	color: rgba(0, 0, 0, 0.3);
}
#doc .sticky-side > span {
	display: inline-block;
	position: sticky;
	left: 0;
	top: 0;
	padding: 0.3em 0;
	max-height: 100%;
	box-sizing: border-box;
	overflow: hidden;
	white-space: nowrap;
}
#doc tt {
	font-weight: bold;
}
#doc code {
	display: inline-block;
	background: #FFFBE4;
	font-family: Consolas, Ubuntu Mono, Dejavu Sans Mono, Lucida Console, monospace;
	font-weight: normal;
	font-size: 12px;
	line-height: 16px;
	padding: 0 2px;
	border: 1px solid #E6E0C4;
	box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
	max-width: 100%;
	word-break: break-word;
}

#doc table {
	border-spacing: 0;
	color: currentColor;
}
#doc table, #doc table td, #doc table th {
	border: 1px solid #f3f3f3;
}
#doc table td, #doc table th {
	padding: 0.1em 0.5em;
}
#doc pre {
	font-family: Consolas, Dejavu Sans Mono, Segoe UI Mono, Ubuntu Mono, Lucida Console, monospace;
	font-size: 9pt;
	line-height: 1.25;
	background: white;
	padding: 4px 2px 4px 10px;
	margin: 0;
	-moz-tab-size: 4;
	tab-size: 4;
	overflow-x: auto;
	white-space: pre-wrap;
	word-break: break-all;
}
#doc pre a {
	text-decoration: none;
}
#doc pre a:hover {
	text-decoration: underline;
}
#doc abbr[title] {
	text-decoration: underline;
	-webkit-text-decoration-color: #bbb;
	text-decoration-color: #bbb;
	-webkit-text-decoration-style: double;
	text-decoration-style: double;
}
#doc hr {
	margin: 0.5em 0;
	margin-right: 1em;
	border: 0;
	border-top: 2px dashed #f3f3f3;
}
#doc section + hr {
	margin: 0;
	height: 1em;
	border: 1px solid #f3f3f3;
	border-width: 1px 0 1px 0;
}
#doc section {
	border-top: 1px solid #f3f3f3;
	margin-top: 0.3em;
}
#doc section:first-child {
	margin-top: 0em;
}
#doc section:last-child {
	border-bottom: 1px solid #f3f3f3;
}
#doc section + section, #doc hr + section {
	border-top: 0;
	margin-top: 0;
}
#doc section + p {
	border-top: 1px solid #f3f3f3;
	padding-top: 0.3em;
}
/* delay display until load */
#doc[ready] section:not(.open) > article {
	display: none;
}</style>
<style type="text/css" id="lang_gml">/* GameMakerLanguage */
pre.gmlmd .md { color: #7A81A9 } /* #define */
pre.gmlmd .kw { color: #008; font-weight: bold } /* keyword */
pre.gmlmd .co { color: #080 } /* comment */
pre.gmlmd .nu { color: #F03232 } /* number */
pre.gmlmd .nx { color: #00f } /* hex */
pre.gmlmd .st { color: #00f } /* string */
pre.gmlmd .ts { color: #00f } /* template string */
pre.gmlmd .op { color: #000 } /* operator */
pre.gmlmd .cb { color: #008; font-weight: bold } /* curly brace */
pre.gmlmd .sv { color: #800 } /* std func */
pre.gmlmd .sf { color: #800 } /* std var */
pre.gmlmd .ri { color: #0078aa } /* assets */
pre.gmlmd .uf { color: #808 } /* user func */
pre.gmlmd .uv { color: #000 } /* user var */
pre.gmlmd .lv { color: #648 } /* local var */
pre.gmlmd .fd { color: #804 } /* field */

pre.gmlmd a.uf {
	background-color: #f7f0ff;
}
pre.gmlmd a.kw {
	background-color: #f0f7ff;
}
pre.gmlmd a.sf, #doc pre a.sv {
	background-color: #fff3f0;
}

#night:checked + .main pre.gmlmd .op { color: #CCCCCC }
#night:checked + .main pre.gmlmd .co { color: #5B995B }
#night:checked + .main pre.gmlmd .kw { color: #FFB871 }
#night:checked + .main pre.gmlmd .md { color: #FFB871 }
#night:checked + .main pre.gmlmd .cb { color: #FFB871 }
#night:checked + .main pre.gmlmd .sf { color: #FFB871 }
#night:checked + .main pre.gmlmd .uf { color: #FFB871 }
#night:checked + .main pre.gmlmd .nu { color: #FF8080 }
#night:checked + .main pre.gmlmd .st { color: #FCF320 }
#night:checked + .main pre.gmlmd .ts { color: #FF8080 }
#night:checked + .main pre.gmlmd .sv { color: #FF8080 }
#night:checked + .main pre.gmlmd .gv { color: #FF80FF }
#night:checked + .main pre.gmlmd .ri { color: #FF8080 }
#night:checked + .main pre.gmlmd .lv { color: #FFF899 }
#night:checked + .main pre.gmlmd .uv { color: #B2B1FF }
#night:checked + .main pre.gmlmd .fd { color: #B2B1FF }

#night:checked + .main pre.gmlmd a.uf,
#night:checked + .main pre.gmlmd a.kw,
#night:checked + .main pre.gmlmd a.sf {
	background-color: #431;
}
#night:checked + .main pre.gmlmd a.sv {
	background-color: #422;
}</style>
<style type="text/css" id="night_css">.main label[for="night"] {
	cursor: pointer;
}
#night { display: none }
#night:checked + .main {
	background-color: #424242;
}
#night:checked + .main .page {
	background-color: #1c1c1c;
	box-shadow: 0 0 10px rgba(0, 0, 0, 0.3);
	color: white;
}
#night:checked + .main a,
#night:checked + .main a:visited,
#night:checked + .main #doc header,
#night:checked + .main label[for="night"] {
	color: #9DEC76;
}
#night:checked + .main #doc header:before,
#night:checked + .main #doc h3 {
	border-color: #9DEC76
}
#night:checked + .main #doc header,
#night:checked + .main #doc header:hover,
#night:checked + .main #doc .sticky-side:hover,
#night:checked + .main #doc article,
#night:checked + .main #doc section,
#night:checked + .main #doc section + p,
#night:checked + .main #doc hr,
#night:checked + .main #doc ul,
#night:checked + .main #doc table,
#night:checked + .main #doc table td,
#night:checked + .main #doc table th
{
	border-color: rgba(205,225,255,0.1);
}
#night:checked + .main #doc header:hover,
#night:checked + .main #doc .sticky-side:hover,
#night:checked + .main #doc .asset:hover {
	background: rgba(205,225,255,0.1);
}
#night:checked + .main article ul li {
	list-style-image: url('data:image/svg+xml;base256,<?xml version="1.0" encoding="UTF-8"?><svg xmlns="http://www.w3.org/2000/svg" width="20px" height="1em" viewBox="0 0 20px 1em"><circle cx="17px" cy="0.675em" r="2px" fill="white"/></svg>'); 
}
#night:checked + .main pre {
	color: #cccccc;
	background: #000000;
	border: 1px solid #3E4757;
}
#night:checked + .main #doc code {
	background-color: #000;
	border-color: #5b7c9f;
	color: white;
}
#night:checked + .main #doc .sticky-side,
#night:checked + .main #doc .sticky-side:visited {
	color: rgba(255, 255, 255, 0.3);
}</style>
<style type="text/css" id="print_css">@media print {
	.main { background-color: transparent }
	.display-controls { display: none; }
	.page { width: 100%; box-shadow: none; }
	#doc header::before,
	#doc section.open header::before	{
		content: "~";
	}
	#doc { display: inherit }
	#doc section:not(.open) > article,
	#doc[ready] section:not(.open) > article {
		display: inherit;
	}
}</style>
<noscript><style>#doc header::before {
	content: "~";
}
#doc header:hover {
	border-left-color: #f3f3f3;
	background: inherit;
}
#doc { display: inherit }
#doc section:not(.open) > article {
	display: inherit;
}</style></noscript>
</head><body>
<input type="checkbox" id="night" checked/>
<div class="main boxtt">
<script type="text/javascript">(function() {
	var night = document.getElementById("night");
	var path = "docmd night mode";
	var ls = window.localStorage;
	var dark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
	if (ls) {
		var item = ls.getItem(path);
		night.checked = item ? item == "true" : dark;
		night.onchange = function(_) {
			ls.setItem(path, "" + night.checked);
		};
	} else night.checked = dark;
})();</script>
<main class="page">
<section class="intro">
	<h1 style='transform: skewX(-5deg); margin: 0.5em 0;'>GMLive.gml</h1>
	<p>
This is a "cheat sheet" for the GMLive.gml extension by <a href="https://yal.cc">YellowAfterlife</a>.
</p><p>
The extension can be acquired from
<a href="https://marketplace.yoyogames.com/assets/5992/_">GM:Marketplace</a>
or <a href="https://yellowafterlife.itch.io/gamemaker-live">itch.io</a>.
</p><p>
For questions/support, use <a href="https://yellowafterlife.itch.io/gamemaker-live/community">forums</a>,
or <a href="mailto://yellowafterlife@hotmail.com">send me an email</a>.  <br/>
</p><p>
An up-to-date version of this document can always be found <a href="https://yal.cc/r/17/gmlive">online</a>.</p></section>
<section class="display-controls">
Click on sections to expand/collapse them.<br>Quick display controls:
<a href="javascript:void(0)" onclick="opt_none(); return false">Categories</a>
&middot; <a href="javascript:void(0)" onclick="opt_list(); return false">Sections</a>
&middot; <a href="javascript:void(0)" onclick="opt_all(); return false">Everything</a>
&middot; <a href="javascript:void(0)"><label for="night">Toggle night mode</label></a><br/>
</section><section id="doc">
<!--<doc--><p><p>

<style>
.main { background-color: #899FC6 }
.page { box-shadow: 0 0 8px rgba(0, 0, 0, 0.3) }
#night:checked + .main { background-color: #405070 }
#night:checked + .main .page { background-color: #1A202D }
</style>










</p><section><header id="old"><a href="#old" title="(permalink)">A note on old GameMaker versions</a></header><article><p>
	This document is for the current version of GMLive,
	which works with the recent GameMaker versions
	(GameMaker 2022 and newer, including LTS).
	</p><p>
	I also offer several archived versions of GMLive for use with old GameMaker versions,
	such as GameMaker: Studio or GameMaker Studio 2.2.x.
	</p><p>
	These versions of GMLive are no longer actively supported and have slightly fewer
	features than the latest ones, but still are fairly stable and have been used
	in numerous games during their time.
	</p><p>
	For convenience, archived documentation from these versions is available separately:
	</p><ul>
	<li>	<a href="https://yal.cc/docs/gm/gmlive/gms1/">GameMaker: Studio</a>
	</li><li>	<a href="https://yal.cc/docs/gm/gmlive/gms2/">GameMaker Studio 2.2.x</a>
	</li><li>	<a href="https://yal.cc/docs/gm/gmlive/gms23/">GameMaker Studio 2.3.x</a>
	</li></ul></article></section><section><header id="use2"><a href="#use2" title="(permalink)">Using GMLive.gml</a></header><article><a class="sticky-side" href="#use2" title="Using GMLive.gml"><span>Using GMLive.gml</span></a><section><header id="gms2-setup"><a href="#gms2-setup" title="(permalink)">Initial setup</a></header><article><ul>
		<li><p>	Import the GMLive asset the project: </p><ul>
			<li>	If you bought the asset on GM Marketplace, you can import it using menu:MarketplaceâMy Library.
			</li><li>	If you bought the asset on itch.io, you can import it using menu:ToolsâImport Local Asset Package,
				or by dragging and dropping the <code>.yymps</code> file onto the workspace area (where the resource editor windows show up) of the GameMaker window.<br/>
				<strong>Note:</strong> <code>.yymp</code> is for GMS2.2.x, <code>.yymps</code> is for the current versions.
			</li></ul></li><li>	Import the assets (extension, object, and included files) from the package.<br/>
			<strong>Note:</strong> On Mac/Linux, omit importing Windows-specific <code>exe</code> and <code>ndll</code> files.
		</li><li>	On Mac/Linux, install <a href="https://nekovm.org/download/">Neko VM</a> if you haven't already.<br/>
			Neko VM is a tiny (1.5 .. 3.2MB) runtime for cross-platform applications that I use
			for GMLive's server application.
		</li><li>	Place <code>obj_gmlive</code> in the first room of the project.
		</li></ul></article></section><section><header id="gms2-start"><a href="#gms2-start" title="(permalink)">Starting up (Windows)</a></header><article><ul>
			<li>	Open your project directory using menu:Help â Open project in Explorer<br/>
				(or navigate to it manually)
			</li><li>	Navigate to <code>datafiles</code> â <code>GMLive</code>
			</li><li>	Open <code>gmlive-server.exe</code><br/>
				(you may also run it from Command Prompt/PowerShell/etc. if you prefer)
			</li><li>	Once the server window says "Project load took Xms", the server is ready to go.<br/>
			You can leave it running when recompiling the game -
			it will re-scan the project directory whenever a new game instance connects to it.
		</li><li>	Add <a href="#api-live">live function calls</a> to scripts and events of interest.<br/>
			Note that the event must be GML-type (not a DND space with a GML block)
		</li><li>	Run the game.
		</li><li>	Change the "live" scripts/events as you see fit, save the file/project
			(<strong>this is important</strong>) and see the changes in-game
			(if everything was done correctly).  <br/>
			gmlive-server's window will report status updates.
		</li></ul></article></section><section><header id="gms2-start-mac"><a href="#gms2-start-mac" title="(permalink)">Starting up (Mac/Linux)</a></header><article><ul>
			<li>	Open your project directory using menu:Help â Show Project In Finder/File Manager<br/>
				(or navigate to it manually)
			</li><li>	Navigate to <code>datafiles</code> â <code>GMLive</code>
			</li><li>	Open a Terminal window in the folder.<br/>
				On Mac, this is done using menu:Finder â Services â New Terminal at Folder.<br/>
				On Linux, this depends on your file manager and/or desktop environment.<br/>
				I trust you to know how to open Terminal if you have chosen Linux as your OS.
			</li><li>	Type <code>neko gmlive-server.n</code> and press Enter.<br/>
				If all is well, you'll see "Starting up... (protocol version: ...".<br/>
			</li><li>	Once the server window says "Project load took Xms", the server is ready to go.<br/>
			You can leave it running when recompiling the game -
			it will re-scan the project directory whenever a new game instance connects to it.
		</li><li>	Add <a href="#api-live">live function calls</a> to scripts and events of interest.<br/>
			Note that the event must be GML-type (not a DND space with a GML block)
		</li><li>	Run the game.
		</li><li>	Change the "live" scripts/events as you see fit, save the file/project
			(<strong>this is important</strong>) and see the changes in-game
			(if everything was done correctly).  <br/>
			gmlive-server's window will report status updates.
		</li></ul></article></section><section><header id="gms2-export"><a href="#gms2-export" title="(permalink)">Exporting</a></header><article><p>
		GMLive extension works by communicating with <code>gmlive-server</code> over network,
		which can be undesirable (or even forbidden, depending on platform)
		in release builds of your game.
		</p><p>
		For this reason I recommend disabling GMLive prior to exporting.
		</p><p>
		To do so, change the value of <code>live_enabled</code> macro in <code>obj_gmlive</code>'s Create event to <code>0</code>.
		</p><p>
		Doing so strips out majority of GMLive's code,
		leaving only a handful of dummy functions that will return default values when called.
		</p><p>
		After exporting you can set <code>live_enabled</code> back to <code>1</code>.
		</p><p>
		If you are using configurations, you can set up a configuration-specific macro
		to automate this, like so:
		</p><pre class="gmlmd">
<span class="md">#macro</span> <span class="uf">Release</span><span class="op">:</span><span class="uf">live_enabled</span> <span class="nu">0</span>
</pre><p>
		If you rely on <a href="#live_execute_string">live_execute_string</a> and/or <a href="#live_snippet_create">Snippet API</a>,
		you may want to instead disable server communication by passing <code>undefined</code>
		instead of the URL in <a href="#live_init">live_init</a>.
	</p></article></section></article></section><section><header>General functions</header><article><section><header id="live_init"><a href="#live_init" title="(permalink)">live_init(update_rate, url, password)</a></header><article><p>
		This function initializes GMLive
		and initiates the connection to gmlive-server.
		</p><p>
		<code>update_rate</code> is how often files should be checked for updates, in seconds.
		<code>1</code> is a common value. Lower values can load changed files faster,
		but will also cause file system to be polled more frequently.
		</p><p>
		<code>url</code> is the URL that gmlive-server is running on.<br/>
		Typically you'll want something like <code>"http://127.0.0.1:5100"</code>
		to connect to the server on the same machine.<br/>
		Passing <code>undefined</code> instead of the URL prevents the connection while allowing
		to use GMLive's utility functions (e.g. <a href="#live_execute_string">live_execute_string</a>).
		</p><p>
		<code>password</code> is the password set via gmlive-server's <code>--password</code> option,
		as a basic form of security if running the server in an unprotected network.
		If you did not specify one, this should be left as a blank string.
	</p></article></section><section><header id="live_log_script"><a href="#live_log_script" title="(permalink)">live_log_script:script(debug_text, log_level)</a></header><article><p>
		You can assign a script into this global variable
		and GMLive will call it whenever it wants to display some debug information
		(such as notifications about scripts being reloaded).
		</p><p>
		If not assigned, plain <code>show_debug_message</code> calls are used.
		</p><p>
		<code>log_level</code> can be 0 (info), 1 (warning), or 2 (error).
		</p><p>
		For example,
		</p><pre class="gmlmd">
<a class="sv" href="#live_log_script">live_log_script</a> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="lv">text</span><span class="op">,</span> <span class="lv">level</span><span class="op">)</span> <span class="cb">{</span>
    <span class="sf">show_debug_message</span><span class="op">(</span><span class="lv">text</span><span class="op">)</span><span class="op">;</span>
    <span class="kw">if</span> <span class="op">(</span><span class="lv">level</span> <span class="op">==</span> <span class="nu">2</span><span class="op">)</span> <span class="cb">{</span>
        <span class="co">// make a beep</span>
    <span class="cb">}</span>
<span class="cb">}</span>
</pre></article></section><section><header id="live_execute_string"><a href="#live_execute_string" title="(permalink)">live_execute_string(gml_code, ...arguments)&#8203;<span class="ret-arrow">&#10140;</span>ok?</a></header><article><p>
		Attempts to compile and run a snippet of GML code.
		</p><p>
		Returns whether execution succeeded. If it did, <code>live_result</code> contains the returned value (if any). If it didn't, <code>live_result</code> contains the error text.
		</p><pre class="gmlmd">
<span class="kw">if</span> <span class="op">(</span><a class="sf" href="#live_execute_string">live_execute_string</a><span class="op">(</span><span class="st">@'show_message("Hello!"); return 1'</span><span class="op">)</span><span class="op">)</span> <span class="cb">{</span>
    <span class="sf">show_debug_message</span><span class="op">(</span><span class="st">"Result: "</span> <span class="op">+</span> <span class="sf">string</span><span class="op">(</span><a class="sv" href="#live_result">live_result</a><span class="op">)</span><span class="op">)</span><span class="op">;</span>
<span class="cb">}</span> <span class="kw">else</span> <span class="sf">show_debug_message</span><span class="op">(</span><span class="st">"Error: "</span> <span class="op">+</span> <span class="sf">string</span><span class="op">(</span><a class="sv" href="#live_result">live_result</a><span class="op">)</span><span class="op">)</span><span class="op">;</span>
</pre><p>
		Please keep in mind that much like the similarly-named GM&lt;=8.1 function, this compiles code on every call, thus is not fast and should only be used for debugging (e.g. if you want to be able to type snippets of GML in-game for quick tests)
		- use <a href="#live_snippet_create">live_snippet_create</a> if you need to repeatedly execute dynamic code.
	</p></article></section><hr/><section><header id="live_snippet_create"><a href="#live_snippet_create" title="(permalink)">live_snippet_create(gml_code, name = "snippet")&#8203;<span class="ret-arrow">&#10140;</span>snippet</a></header><article><p>
		Creates a new "snippet" from a string of code.
		</p><p>
		Since this pre-compiles code, doing so is faster than live_execute_string for cases where you would want to repeatedly execute the same dynamic code snippet (in parallel with <code>object_event_add</code> in legacy GameMaker).
		</p><p>
		If there is a compilation error, the function returns <code>undefined</code> and stores the error text in <code>live_result</code>.
		</p><pre class="gmlmd">
<span class="kw">var</span> <span class="lv">snip</span> <span class="op">=</span> <a class="sf" href="#live_snippet_create">live_snippet_create</a><span class="op">(</span><span class="st">@'show_debug_message(argument0 * 2);'</span><span class="op">)</span><span class="op">;</span>
<span class="kw">if</span> <span class="op">(</span><span class="lv">snip</span> <span class="op">!=</span> <span class="sv">undefined</span><span class="op">)</span> <span class="cb">{</span>
    <a class="sf" href="#live_snippet_call">live_snippet_call</a><span class="op">(</span><span class="lv">snip</span><span class="op">,</span> <span class="nu">3</span><span class="op">)</span><span class="op">;</span> <span class="co">// -&gt; 6</span>
    <a class="sf" href="#live_snippet_call">live_snippet_call</a><span class="op">(</span><span class="lv">snip</span><span class="op">,</span> <span class="nu">5</span><span class="op">)</span><span class="op">;</span> <span class="co">// -&gt; 10</span>
    <a class="sf" href="#live_snippet_destroy">live_snippet_destroy</a><span class="op">(</span><span class="lv">snip</span><span class="op">)</span><span class="op">;</span>
<span class="cb">}</span> <span class="kw">else</span> <span class="sf">show_debug_message</span><span class="op">(</span><span class="st">"Error: "</span> <span class="op">+</span> <span class="sf">string</span><span class="op">(</span><a class="sv" href="#live_result">live_result</a><span class="op">)</span><span class="op">)</span><span class="op">;</span>
</pre><p>
		Don't forget to <a href="#live_snippet_destroy">destroy</a> your snippets to free up memory when you're done using them!
	</p></article></section><section><header id="live_snippet_call"><a href="#live_snippet_call" title="(permalink)">live_snippet_call(snippet, ...arguments)&#8203;<span class="ret-arrow">&#10140;</span>ok</a></header><article><p>
		Executes a previously compiled snippet, returns whether successful.
		</p><pre class="gmlmd">
<span class="co">// ...</span>
<span class="kw">if</span> <span class="op">(</span><a class="sf" href="#live_snippet_call">live_snippet_call</a><span class="op">(</span><span class="uv">snip</span><span class="op">,</span> <span class="nu">1</span><span class="op">)</span><span class="op">)</span> <span class="cb">{</span>
    <span class="sf">show_debug_message</span><span class="op">(</span><span class="st">"Result: "</span> <span class="op">+</span> <span class="sf">string</span><span class="op">(</span><a class="sv" href="#live_result">live_result</a><span class="op">)</span><span class="op">)</span><span class="op">;</span>
<span class="cb">}</span> <span class="kw">else</span> <span class="sf">show_debug_message</span><span class="op">(</span><span class="st">"Error: "</span> <span class="op">+</span> <span class="sf">string</span><span class="op">(</span><a class="sv" href="#live_result">live_result</a><span class="op">)</span><span class="op">)</span><span class="op">;</span>
</pre></article></section><section><header id="live_snippet_destroy"><a href="#live_snippet_destroy" title="(permalink)">live_snippet_destroy(snippet)</a></header><article><p>
		Destroys a previously created snippet.
		</p><p>
		Using a snippet after it had been destroyed will generally error.
	</p></article></section></article></section><section><header id="api-live"><a href="#api-live" title="(permalink)">Live functions</a></header><article><a class="sticky-side" href="#api-live" title="Live functions"><span>Live functions</span></a><section><header id="live_call"><a href="#live_call" title="(permalink)">live_call(...arguments)</a></header><article><p>
		Calls the "live" version of the current script/event with specified arguments (if any).
		</p><p>
		Returns whether the "live" version is already loaded and was called.
		</p><p>
		If execution succeeds, <a href="#live_result">live_result</a> contains the returned value.
		</p><p>
		If execution fails, <a href="#live_result">live_result</a> contains <code>0</code> (also see <a href="#live_defcall">live_defcall</a>).
		</p><p>
		For example, if your script takes no arguments, you could do:
		</p><pre class="gmlmd">
<span class="kw">function</span> <span class="uf">scr_test</span><span class="op">(</span><span class="op">)</span> <span class="cb">{</span>
    <span class="kw">if</span> <span class="op">(</span><a class="sf" href="#live_call">live_call</a><span class="op">(</span><span class="op">)</span><span class="op">)</span> <span class="kw">return</span> <a class="sv" href="#live_result">live_result</a><span class="op">;</span>
    <span class="kw">return</span> <span class="st">"Hello!"</span><span class="op">;</span>
<span class="cb">}</span>
</pre><p>
		If your script takes two arguments, you could do:
		</p><pre class="gmlmd">
<span class="kw">function</span> <span class="uf">scr_add</span><span class="op">(</span><span class="lv">a</span><span class="op">,</span> <span class="lv">b</span><span class="op">)</span> <span class="cb">{</span>
    <span class="kw">if</span> <span class="op">(</span><a class="sf" href="#live_call">live_call</a><span class="op">(</span><span class="lv">a</span><span class="op">,</span> <span class="lv">b</span><span class="op">)</span><span class="op">)</span> <span class="kw">return</span> <a class="sv" href="#live_result">live_result</a><span class="op">;</span>
    <span class="kw">return</span> <span class="lv">a</span> <span class="op">+</span> <span class="lv">b</span><span class="op">;</span>
<span class="cb">}</span>
</pre><p>
		If your script takes a varying number of arguments,
		see <a href="#live_call_ext">live_call_ext</a> or <a href="#live_auto_call">live_auto_call</a>.
	</p></article></section><section><header id="live_call_ext"><a href="#live_call_ext" title="(permalink)">live_call_ext(argument_array)</a></header><article><p>
		Same as <a href="#live_call">live_call</a>, but takes arguments in an array instead of a list.
		</p><p>
		You might use it like so:
		</p><pre class="gmlmd">
<span class="kw">var</span> <span class="lv">argument_arr</span> <span class="op">=</span> <span class="sf">array_create</span><span class="op">(</span><span class="sv">argument_count</span><span class="op">)</span><span class="op">;</span>
<span class="kw">for</span> <span class="op">(</span><span class="kw">var</span> <span class="lv">i</span> <span class="op">=</span> <span class="nu">0</span><span class="op">;</span> <span class="lv">i</span> <span class="op">&lt;</span> <span class="sv">argument_count</span><span class="op">;</span> <span class="lv">i</span><span class="op">++</span><span class="op">)</span> <span class="cb">{</span>
    <span class="lv">argument_arr</span><span class="op">[</span><span class="lv">i</span><span class="op">]</span> <span class="op">=</span> <span class="sv">argument</span><span class="op">[</span><span class="lv">i</span><span class="op">]</span><span class="op">;</span>
<span class="cb">}</span>
<span class="kw">if</span> <span class="op">(</span><a class="sf" href="#live_call_ext">live_call_ext</a><span class="op">(</span><span class="lv">argument_arr</span><span class="op">)</span><span class="op">)</span> <span class="kw">return</span> <a class="sv" href="#live_result">live_result</a><span class="op">;</span>
</pre><p>
		However, for specific purpose of passing all of the arguments to a <a href="#live_call">live_call</a>,
		you can most often use <a href="#live_auto_call">live_auto_call</a> in current GameMaker versions.
	</p></article></section><section><header id="live_auto_call"><a href="#live_auto_call" title="(permalink)">live_auto_call</a></header><article><p>
		In GMS2.3.x/GM2022+ version of GMLive,
		this macro is equivalent to packing up arguments
		and calling <a href="#live_call_ext">live_call_ext</a> (as shown above).
		</p><p>
		So, instead of one or other <code>if (live_call...</code> snippet, you can just do
		</p><pre class="gmlmd">
<span class="kw">function</span> <span class="uf">scr_test</span><span class="op">(</span><span class="op">)</span> <span class="cb">{</span>
    <a class="sv" href="#live_auto_call">live_auto_call</a><span class="op">;</span>
    <span class="co">// ...</span>
<span class="cb">}</span>
</pre><p>
		and that's it.
	</p></article></section><section><header id="live_defcall"><a href="#live_defcall" title="(permalink)">live_defcall(...arguments, default_value)</a></header><article><p>
		Same as <a href="#live_call">live_call</a> but returns <code>default_value</code> instead of <code>0</code> if execution fails.
		</p><p>
		This is handy if live-coding a script that may only return values of specific type (thus specifying a default value would allow to avoid errors outside of "live" code).
		</p><p>
		For example,
		</p><pre class="gmlmd">
<span class="co">/// scr_transform_string(string)</span>
<span class="kw">if</span> <span class="op">(</span><a class="sf" href="#live_defcall">live_defcall</a><span class="op">(</span><span class="sv">argument0</span><span class="op">,</span> <span class="st">""</span><span class="op">)</span><span class="op">)</span> <span class="kw">return</span> <a class="sv" href="#live_result">live_result</a><span class="op">;</span>
<span class="co">// (some risky manipulations with string)</span>
</pre><p>
		would return <code>""</code> if execution of the "live" code fails.
	</p></article></section><section><header id="live_defcall_ext"><a href="#live_defcall_ext" title="(permalink)">live_defcall_ext(argument_array, default_value)</a></header><article><p>
		A mix of <a href="#live_call_ext">live_call_ext</a> and <a href="#live_defcall">live_defcall</a> - you can both pass arguments as an array and a default return value.
	</p></article></section><section><header id="live_result"><a href="#live_result" title="(permalink)">live_result</a></header><article><p>
		Stores the returned value from the last <a href="#live_call">live_call</a>
		(or other "live" group functions) if execution succeeded.
		</p><p>
		If the code did not return anything, holds <code>0</code> (GM default for <code>exit</code>).
	</p></article></section><section><header id="live_name"><a href="#live_name" title="(permalink)">live_name</a></header><article><p>
		In GMS2.3+, it can be hard for GMLive to tell apart nested functions due to their
		automatic naming. To mitigate this, a <code>live_name</code> variable is available and can be set
		to any unique string prior to <code>live_call</code> for GMLive to know which function is which.
		</p><p>
		For example,
		</p><pre class="gmlmd">
<span class="kw">function</span> <span class="uf">Greety</span><span class="op">(</span><span class="lv">_name</span><span class="op">)</span> <span class="kw">constructor</span> <span class="cb">{</span>
    <span class="uv">name</span> <span class="op">=</span> <span class="lv">_name</span><span class="op">;</span>
    <span class="kw">static</span> <span class="lv">greet</span> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="op">)</span> <span class="cb">{</span>
        <a class="sv" href="#live_name">live_name</a> <span class="op">=</span> <span class="st">"Greety:greet"</span><span class="op">;</span>
        <span class="kw">if</span> <span class="op">(</span><a class="sf" href="#live_call">live_call</a><span class="op">(</span><span class="op">)</span><span class="op">)</span> <span class="kw">return</span> <a class="sv" href="#live_result">live_result</a><span class="op">;</span>
        <span class="uf">trace</span><span class="op">(</span><span class="st">"A greet from"</span><span class="op">,</span> <span class="uv">name</span><span class="op">)</span>
    <span class="cb">}</span>
<span class="cb">}</span>
</pre></article></section><hr/><section><header id="live_code_updated"><a href="#live_code_updated" title="(permalink)">live_code_updated:function(name, display_name)</a></header><article><p>
		You can assign a function/script to this global variable and it will be called
		whenever a code snippet (script, event, etc.) gets updated, like so:
		</p><pre class="gmlmd">
<a class="sv" href="#live_code_updated">live_code_updated</a> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="lv">name</span><span class="op">,</span> <span class="lv">display_name</span><span class="op">)</span> <span class="cb">{</span>
    <span class="sf">show_debug_message</span><span class="op">(</span><span class="st">"Reloaded "</span> <span class="op">+</span> <span class="lv">display_name</span> <span class="op">+</span> <span class="st">"("</span> <span class="op">+</span> <span class="lv">name</span> <span class="op">+</span> <span class="st">")"</span><span class="op">)</span><span class="op">;</span>
    <span class="co">// any extra logic</span>
<span class="cb">}</span>
</pre><p>
		So, for example, if you were to add the aforementioned code
		to the end of <code>obj_gmlive's</code> Create event and changed something in a live-reloaded
		Draw event of <code>obj_test</code>, you would see something like the following in the Output:
		<blockquote>
		Reloaded obj_test:Draw_0 (gml_Object_obj_test_Draw_0)
</blockquote>
		As you can see, <code>display_name</code> is a (relatively) human-readable name
		and <code>name</code> is whatever GMLive uses to tell this snippet apart
		(typically the script name or the name from <code>debug_get_callstack()</code>)
	</p></article></section><hr/><section><header id="live_call_how"><a href="#live_call_how" title="(permalink)">How does this work, anyway</a></header><article><p>
		You might be wondering what exactly do the different "call" functions do
		and why you have to add them by hand to scripts/events.
		</p><p>
		The way this works is: </p><ul>
		<li>	When you change a file in your project, <code>gmlive-server</code> will note the change
			and will send a new copy to the game when it asks for updates.<br/>
			The extension will then compile the new code to an easier-to-execute form and store it.
		</li><li>	"live" functions first look up where they're being used from.<br/>
			(either through <a href="#live_name">live_name</a> or <code>debug_get_callstack</code>)
		</li><li>	If there's a compiled snippet stored for the location,
			it will be executed, the return value will be stored in <code>live_result</code>,
			and the function will return <code>true</code>.<br/>
			This way the new code executes instead of the original code.
		</li><li>	If there's no compiled snippet for the location,
			the function will return <code>false</code> and the original code will execute.
		</li></ul><p>
		That is also why the calls have to be added manually - there is no way to add a bit of code
		to every single function during compilation without changing every file in the project
		(which is a bad idea for a variety of reasons).
	</p></article></section></article></section><section><header id="sprite"><a href="#sprite" title="(permalink)">Resource functions</a></header><article><a class="sticky-side" href="#sprite" title="Resource functions"><span>Resource functions</span></a><p>
	Apart of the primary feature of live-reloading code,
	GMLive can also live-reload other resource types.
	</p><p>
	As an opening note, <code>set_live</code> functions from this category can be called whenever
	and have little to no overhead for repeated calls,
	so you can set up the callbacks and make yourself a debug console/menu for picking resources
	to live-reload, or even just add-remove a line of code in a "live" script/event.
	</p><section><header id="live_sprite_"><a href="#live_sprite_" title="(permalink)">Sprite functions</a></header><article><a class="sticky-side" href="#live_sprite_" title="Sprite functions"><span>Sprite functions</span></a><section><header id="sprite_set_live"><a href="#sprite_set_live" title="(permalink)">sprite_set_live(sprite, enable)</a></header><article><p>
			Enables/disables live reloading for a specific sprite.
			</p><p>
			Does not work for Spine/SWF sprites (as they cannot be reloaded at runtime)
			and cannot do variable frame timings (since there are no functions for changing this)
			</p><p>
			For example,
			</p><pre class="gmlmd">
<a class="sf" href="#sprite_set_live">sprite_set_live</a><span class="op">(</span><span class="ri">spr_test</span><span class="op">,</span> <span class="sv">true</span><span class="op">)</span><span class="op">;</span>
</pre><p>
			While it might be tempting to call this for <i>all the sprites</i>, usually you should not,
			as the server has to watch "live" sprites and their subimage files for changes,
			and this can add up in disk access time on larger projects.
			</p><p>
			Limitations: </p><ul>
			<li>	Can't reload SWF sprites because there are no functions for doing so.
			</li><li>	Can't reload Spine sprites because I don't know much about these.<br/>
				(but you <i>might</i> be able to do so yourself using <a href="#file_set_live">file_set_live</a>).
			</li><li>	Can't do variable frame timings and broadcast messages.
				because there are no functions for setting them up.
			</li></ul></article></section><section><header id="live_sprite_updated"><a href="#live_sprite_updated" title="(permalink)">live_sprite_updated:function(sprite)</a></header><article><p>
			You can assign a function/script to this global variable and it will be called
			whenever a sprite gets updated, like so:
			</p><pre class="gmlmd">
<a class="sv" href="#live_sprite_updated">live_sprite_updated</a> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="lv">spr</span><span class="op">)</span> <span class="cb">{</span>
    <span class="sf">show_debug_message</span><span class="op">(</span><span class="st">"Reloaded "</span> <span class="op">+</span> <span class="sf">sprite_get_name</span><span class="op">(</span><span class="lv">spr</span><span class="op">)</span><span class="op">)</span><span class="op">;</span>
    <span class="co">// any extra logic</span>
<span class="cb">}</span>
</pre></article></section></article></section><section><header id="live_path_"><a href="#live_path_" title="(permalink)">Path functions</a></header><article><a class="sticky-side" href="#live_path_" title="Path functions"><span>Path functions</span></a><section><header id="path_set_live"><a href="#path_set_live" title="(permalink)">path_set_live(path_ind, enable)</a></header><article><p>
			Enables/disables live reloading for a specific path (the resource type).
			</p><p>
			For example,
			
			</p><pre class="gmlmd">
<a class="sf" href="#path_set_live">path_set_live</a><span class="op">(</span><span class="ri">pt_test</span><span class="op">,</span> <span class="sv">true</span><span class="op">)</span><span class="op">;</span>
</pre><p>
			Note that GameMaker stores path positions as a number in 0..1 range so making a path
			shorter/longer will cause instances following it to jump around as they readjust.
		</p></article></section><section><header id="live_path_updated"><a href="#live_path_updated" title="(permalink)">live_path_updated:function(path)</a></header><article><p>
			Like <a href="#live_sprite_updated">live_sprite_updated</a>, but for paths.
		</p></article></section></article></section><section><header id="live_animcurve_"><a href="#live_animcurve_" title="(permalink)">Animation curve functions</a></header><article><a class="sticky-side" href="#live_animcurve_" title="Animation curve functions"><span>Animation curve functions</span></a><section><header id="animcurve_set_live"><a href="#animcurve_set_live" title="(permalink)">animcurve_set_live(animcurve_ind, enable, ?precision)</a></header><article><p>
			Enables/disables live reloading for a specific animation curve.
			</p><p>
			Optional precision determines bezier curve iterations.
			</p><p>
			For example,
			
			</p><pre class="gmlmd">
<a class="sf" href="#animcurve_set_live">animcurve_set_live</a><span class="op">(</span><span class="ri">ac_test</span><span class="op">,</span> <span class="sv">true</span><span class="op">)</span><span class="op">;</span>
</pre></article></section><section><header id="live_animcurve_updated"><a href="#live_animcurve_updated" title="(permalink)">live_animcurve_updated:function(animcurve)</a></header><article><p>
			Like <a href="#live_sprite_updated">live_sprite_updated</a>, but for animation curves.
		</p></article></section></article></section><section><header id="file_set_live"><a href="#file_set_live" title="(permalink)">file_set_live(path, ?callback, ?kind)</a></header><article><p>
		Enables/disables live reloading for a specific included file.
		</p><p>
		This can be used for live-updating game data, localization, or anything else.
		</p><p>
		<code>path</code> is a <i>relative</i> path to the file (e.g. <code>some.txt</code>, or <code>GMLive/gmlive.html</code>).<br/>
		You may go out of the included file directory using <code>../</code> to read other files
		inside the project directory (e.g. <code>../notes/mynote/mynote.txt</code>), but not files outside
		of the project directory.
		</p><p>
		<code>callback</code> is a function/script that will be called whenever the file changes.<br/>
		The function's first argument will be the new contents (more on this later)
		and the second argument will be the relative path (as provided here).<br/>
		Omit this argument or set it to <code>undefined</code> to disable live reloading.
		</p><p>
		<code>kind</code> is a string determining how to load the file. It can be one of the following: </p><ul>
		<li>	<code>"text"</code>: provides file contents as a string.
		</li><li>	<code>"buffer"</code>: provides file contents as a buffer.<br/>
			Note that the buffer will be automatically deleted later so you should copy the data
			from it somewhere as necessary.
		</li><li>	<code>"csv"</code>: provides file contents as a CSV grid (using <code>load_csv</code>).<br/>
			Similarly, the grid will be automatically deleted afterwards.
		</li><li>	<code>"json"</code>: provides file contents as a JSON value, provided that it's valid JSON.
		</li><li>	<code>"base64"</code>: provides file contents as a base64 string.<br/>
			This is the format data is originally received in and is convenient if you intend
			to decode it yourself as you please.
		</li></ul><p>
		If <code>kind</code> is not specified or is set to <code>"auto"</code>, it will be auto-detected based on file extension: </p><ul>
		<li>	<code>.txt</code> â <code>"text"</code>
		</li><li>	<code>.json</code> â <code>"json"</code>
		</li><li>	<code>.bin</code> â <code>"buffer"</code>
		</li><li>	<code>.csv</code> â <code>"csv"</code>
		</li><li>	<code>.b64</code>, <code>.base64</code> â <code>"base64"</code>
		</li></ul><p>
		If the file extension is not recognized, an error is thrown.
		</p><p>
		Example (assuming that you have a <code>test.txt</code> in your Included Files):
		</p><pre class="gmlmd">
<a class="sf" href="#file_set_live">file_set_live</a><span class="op">(</span><span class="st">"test.txt"</span><span class="op">,</span> <span class="kw">function</span><span class="op">(</span><span class="lv">_text</span><span class="op">,</span> <span class="lv">_path</span><span class="op">)</span> <span class="cb">{</span>
    <span class="sf">show_debug_message</span><span class="op">(</span><span class="lv">_path</span> <span class="op">+</span> <span class="st">" has been updated: "</span> <span class="op">+</span> <span class="lv">_text</span><span class="op">)</span><span class="op">;</span>
<span class="cb">}</span><span class="op">)</span><span class="op">;</span>
</pre><p>
		With a file type override:
		</p><pre class="gmlmd">
<a class="sf" href="#file_set_live">file_set_live</a><span class="op">(</span><span class="st">"test.txt"</span><span class="op">,</span> <span class="kw">function</span><span class="op">(</span><span class="lv">_buf</span><span class="op">,</span> <span class="lv">_path</span><span class="op">)</span> <span class="cb">{</span>
    <span class="sf">show_debug_message</span><span class="op">(</span><span class="lv">_path</span> <span class="op">+</span> <span class="st">" is now "</span> <span class="op">+</span> <span class="sf">buffer_get_size</span><span class="op">(</span><span class="lv">_buf</span><span class="op">)</span> <span class="op">+</span> <span class="st">" bytes long"</span><span class="op">)</span><span class="op">;</span>
<span class="cb">}</span><span class="op">,</span> <span class="st">"buffer"</span><span class="op">)</span><span class="op">;</span>
</pre><p>
		Disabling live-reloading:
		</p><pre class="gmlmd">
<a class="sf" href="#file_set_live">file_set_live</a><span class="op">(</span><span class="st">"test.txt"</span><span class="op">,</span> <span class="sv">undefined</span><span class="op">)</span><span class="op">;</span>
</pre></article></section><section><header id="room"><a href="#room" title="(permalink)">Room functions</a></header><article><a class="sticky-side" href="#room" title="Room functions"><span>Room functions</span></a><section><header id="room-setup"><a href="#room-setup" title="(permalink)">Setting up</a></header><article><ul>
			<li>	Create an empty object and name it, for example, <code>obj_blank</code>;
			</li><li><p>	Create an empty room and name it, for example, <code>rm_blank</code>;
				If using GMS2, remove the default instance and background layers;
				Add the following to its Room Creation Code:
				</p><pre class="gmlmd">
<span class="sf">live_room_start</span><span class="op">(</span><span class="op">)</span><span class="op">;</span>
</pre></li><li><p>	Assign the two to <code>live_blank_object</code> and <code>live_blank_room</code> in <code>obj_gmlive</code>'s Create event:
				</p><pre class="gmlmd">
<span class="sv">live_blank_object</span> <span class="op">=</span> <span class="ri">obj_blank</span><span class="op">;</span>
<span class="sv">live_blank_room</span> <span class="op">=</span> <span class="ri">rm_blank</span><span class="op">;</span>
</pre></li></ul></article></section><section><header id="room_set_live"><a href="#room_set_live" title="(permalink)">room_set_live(room, enable)</a></header><article><p>
			Enables/disables live reload for a specific room. Don't forget to <a href="#room-setup">setup helper resources</a> first.
			</p><p>
			For example,
			
			</p><pre class="gmlmd">
<a class="sf" href="#room_set_live">room_set_live</a><span class="op">(</span><span class="ri">rm_test</span><span class="op">,</span> <span class="sv">true</span><span class="op">)</span><span class="op">;</span>
</pre><p>
			Can be called at runtime, including from "live" code.
		</p></article></section><section><header id="room_goto_live"><a href="#room_goto_live" title="(permalink)">room_goto_live(room)</a></header><article><p>
			Transits to the specified room much like regular <code>room_goto</code>.
			</p><p>
			If a "live" version of the room is loaded, transits to <code>live_blank_room</code>
			instead and loads the new version of the room there.
		</p></article></section><section><header id="live_room_updated"><a href="#live_room_updated" title="(permalink)">live_room_updated</a></header><article><p>
			If set, this script will be called whenever a new version of a room is received.
			</p><p>
			By default this does an equivalent of
			</p><pre class="gmlmd">
<a class="sv" href="#live_room_updated">live_room_updated</a> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="lv">_rm</span><span class="op">)</span> <span class="cb">{</span>
    <a class="sf" href="#room_goto_live">room_goto_live</a><span class="op">(</span><span class="lv">_rm</span><span class="op">)</span><span class="op">;</span>
<span class="cb">}</span><span class="op">;</span>
</pre><p>
			but you can also add your own logic this way.
		</p></article></section><section><header id="room-lims"><a href="#room-lims" title="(permalink)">Limitations</a></header><article><a class="sticky-side" href="#room-lims" title="Limitations"><span>Limitations</span></a><section><header id="room-lims-by-name"><a href="#room-lims-by-name" title="(permalink)">Referencing "live" instances by name from non-"live" code</a></header><article><p>
				Since instance names are transformed into hardcoded instance IDs during compilation, this will not work.<br/>
				Consider assigning instances of interest into global variables in room creation code
				if you need to - that way you'll assign IDs that were given out to "live" versions as
				the "live" code would know the "new" ones.
			</p></article></section><section><header id="room-lims-_"><a href="#room-lims-_" title="(permalink)">(anything else?)</a></header><article><p>
				This feature is relatively new and the topic of room loading is relatively complex so
				it is possible that you'll encounter some issues that I've not even thought of testing for.
				Make sure to report things that break!
			</p></article></section></article></section></article></section><section><header id="shader"><a href="#shader" title="(permalink)">Shader functions</a></header><article><a class="sticky-side" href="#shader" title="Shader functions"><span>Shader functions</span></a><p>
		These are currently experimental.
		</p><section><header id="shader-setup"><a href="#shader-setup" title="(permalink)">Setting up</a></header><article><p>
			First, you will need an extension that can replace shaders with new ones.
			</p><p>
			As of 2024, the only such extension is seemingly
			<a href="https://yellowafterlife.itch.io/gamemaker-shader-replace-simple">my own</a>,
			which is Windows-only and has some limitations,
			but at least it doesn't break often.
		</p></article></section><section><header id="live_shader_updated"><a href="#live_shader_updated" title="(permalink)">live_shader_updated:script(shader, hlsl_vertex_code, hlsl_pixel_code)</a></header><article><p>
			A script should be assigned to this variable and will be executed whenever a shader should be reloaded.
			</p><p>
			For example,
			</p><pre class="gmlmd">
<a class="sv" href="#live_shader_updated">live_shader_updated</a> <span class="op">=</span> <span class="kw">function</span><span class="op">(</span><span class="lv">shader</span><span class="op">,</span> <span class="lv">hlsl_vertex_code</span><span class="op">,</span> <span class="lv">hlsl_pixel_code</span><span class="op">)</span> <span class="cb">{</span>
    <span class="co">// ... call your respective function to replace the shader</span>
<span class="cb">}</span>
</pre><p>
			GMLive will automatically assign <code>shader_replace_simple</code>'s function if available.
		</p></article></section><section><header id="shader_set_live"><a href="#shader_set_live" title="(permalink)">shader_set_live(shader, enable)</a></header><article><p>
			Enables/disables live reloading for a specific shader.
			</p><p>
			For example,
			</p><pre class="gmlmd">
<a class="sf" href="#shader_set_live">shader_set_live</a><span class="op">(</span><span class="uv">sh_test</span><span class="op">,</span> <span class="sv">true</span><span class="op">)</span><span class="op">;</span>
</pre><p>
			Can be called at runtime, including from "live" code.
		</p></article></section></article></section></article></section><section><header id="api"><a href="#api" title="(permalink)">API functions</a></header><article><a class="sticky-side" href="#api" title="API functions"><span>API functions</span></a><p>
	The following functions are designed to add/override how GMLive will compile code
	and are designed for rare cases where something doesn't work right
	or to get around limitations with calling extension functions.
	</p><p>
	Note that changing the API only affects newly compiled live code / snippets
	- you should usually call these on game start / in <code>obj_gmlive</code>'s Create event.
	</p><section><header id="live_function_add"><a href="#live_function_add" title="(permalink)">live_function_add(signature, impl)</a></header><article><p>
		Registers a function for use in GMLive code / snippets.
		</p><p>
		<code>signature</code> is function signature, including the name, such as: </p><ul>
		<li>	<code>clamp(a, b, c)</code> (normal),
		</li><li>	<code>instance_destroy(?id, ?execEvent)</code> (prepend optional arguments with <code>?</code>)
		</li><li>	<code>max(...values)</code> (include <code>...</code> for trailing arguments).
		</li></ul><p>
		Trailing content (such as the various characters from <code>fnames</code>) is allowed,
		but will be ignored.
		</p><p>
		<code>impl</code> (a script in 2.2, a function in 2.3)
		will then be called with provided arguments as normal.
		</p><p>
		For example,
		</p><pre class="gmlmd">
<a class="sf" href="#live_function_add">live_function_add</a><span class="op">(</span><span class="st">"video_open(path)"</span><span class="op">,</span> <span class="kw">function</span><span class="op">(</span><span class="lv">path</span><span class="op">)</span> <span class="cb">{</span>
    <span class="uf">video_open</span><span class="op">(</span><span class="lv">path</span><span class="op">)</span><span class="op">;</span>
<span class="cb">}</span><span class="op">)</span><span class="op">;</span>
</pre><p>
		You may call <a href="#live_throw_error">live_throw_error</a> to hand an error back to the executing "live" code
		(such as noting that arguments are mis-typed if this would result in a catastrophic error otherwise).
	</p></article></section><section><header id="live_variable_add"><a href="#live_variable_add" title="(permalink)">live_variable_add(signature, impl)</a></header><article><p>
		Registers a global built-in variable for use in GMLive.
		</p><p>
		<code>signature</code> is the variable signature in <code>fnames</code> format: </p><ul>
		<li>	<code>room_speed</code> (a read/write variable)
		</li><li>	<code>fps*</code> (a read-only variable)
		</li><li>	<code>view_xport[]</code> (an array)
		</li></ul><p>
		<code>impl</code> (a script in 2.2, a function in 2.3)
		will be called with the following arguments: </p><ul>
		<li>	<code>argument0</code>: whether writing (true) or reading (false) the variable.
		</li><li>	<code>argument1</code>: if writing the variable, this contains the new value.
		</li><li>	<code>argument2</code>: if the variable is an array, this contains the index.<br/>
			Please note that, honoring how GameMaker (still!) works,
			<code>a = view_xport;</code> is equivalent to <code>a = view_xport[0];</code>.
		</li></ul><p>
		You may call <a href="#live_throw_error">live_throw_error</a> to hand an error back to the executing "live" code
		(such as preventing out-of-bounds array access for fixed-size arrays
		or performing value validation on write).
		</p><p>
		For example,
		</p><pre class="gmlmd">
<a class="sf" href="#live_variable_add">live_variable_add</a><span class="op">(</span><span class="st">"my_room_speed"</span><span class="op">,</span> <span class="uf">scr_my_room_speed</span><span class="op">)</span><span class="op">;</span>
<span class="co">// and then in scr_my_room_speed</span>
<span class="kw">if</span> <span class="op">(</span><span class="sv">argument0</span><span class="op">)</span> <span class="cb">{</span>
    <span class="sv">room_speed</span> <span class="op">=</span> <span class="sv">argument1</span><span class="op">;</span>
<span class="cb">}</span> <span class="kw">else</span> <span class="kw">return</span> <span class="sv">room_speed</span><span class="op">;</span>
</pre><p>
		or, in 2.3,
		</p><pre class="gmlmd">
<a class="sf" href="#live_variable_add">live_variable_add</a><span class="op">(</span><span class="st">"my_room_speed"</span><span class="op">,</span> <span class="kw">function</span><span class="op">(</span><span class="lv">set</span><span class="op">,</span> <span class="lv">val</span><span class="op">)</span> <span class="cb">{</span>
    <span class="kw">if</span> <span class="op">(</span><span class="lv">set</span><span class="op">)</span> <span class="cb">{</span>
        <span class="sv">room_speed</span> <span class="op">=</span> <span class="lv">val</span><span class="op">;</span>
    <span class="cb">}</span> <span class="kw">else</span> <span class="kw">return</span> <span class="sv">room_speed</span><span class="op">;</span>
<span class="cb">}</span><span class="op">)</span><span class="op">;</span>
</pre></article></section><section><header id="live_constant_add"><a href="#live_constant_add" title="(permalink)">live_constant_add(name, value)</a></header><article><p>
		Registers a constant for use in GMLive.
		</p><p>
		There isn't much to this one - name and value.
		</p><pre class="gmlmd">
<a class="sf" href="#live_constant_add">live_constant_add</a><span class="op">(</span><span class="st">"MATCHMAKING_SESSION"</span><span class="op">,</span> <span class="uv">MATCHMAKING_SESSION</span><span class="op">)</span><span class="op">;</span>
</pre></article></section><section><header id="live_throw_error"><a href="#live_throw_error" title="(permalink)">live_throw_error(text)</a></header><article><p>
		When ran from a function that is being ran by live code / snippet,
		this passes an error message to GMLive, which will abort code execution.
		</p><p>
		In GMS2.3 you may instead use <code>show_error</code> or <code>throw</code>.
	</p></article></section><p>
	I cannot think of why you would want to unregister API entries, but, just in case:
	</p><section><header>live_function_remove(name)</header><article><p>
		Removes a previously registered function.
	</p></article></section><section><header>live_variable_remove(name)</header><article><p>
		Removes a previously registered global built-in variable.
	</p></article></section><section><header>live_constant_remove(name)</header><article><p>
		Removes a previously registered constant.
	</p></article></section></article></section><section><header id="misc"><a href="#misc" title="(permalink)">GMS2.3+ functions</a></header><article><a class="sticky-side" href="#misc" title="GMS2.3+ functions"><span>GMS2.3+ functions</span></a><section><header id="live_method"><a href="#live_method" title="(permalink)">live_method(self, func)&#8203;<span class="ret-arrow">&#10140;</span>method</a></header><article><p>
		Like the built-in <code>method</code> function,
		but supports re-binding functions produced by GMLive code.
	</p></article></section><section><header id="live_method_get_self"><a href="#live_method_get_self" title="(permalink)">live_method_get_self(func)&#8203;<span class="ret-arrow">&#10140;</span></a></header><article><p>
		Like the built-in <code>method_get_self</code> function,
		but returns correct values for functions produced by GMLive code.
	</p></article></section></article></section><section><header id="tech"><a href="#tech" title="(permalink)">Technical topics</a></header><article><a class="sticky-side" href="#tech" title="Technical topics"><span>Technical topics</span></a><section><header id="gmlive-server"><a href="#gmlive-server" title="(permalink)">gmlive-server</a></header><article><p>
		Is a helper application for GMLive.gml. It does a few things: </p><ul>
			<li>	Fetches resources from the project.
			</li><li>	Watches "live" files for changes.
			</li><li>	Sends updated files to the game.
		</li></ul><p>
		Starting up without arguments (such as by double-clicking the executable) has it automatically
		look for a GMS1/GMS2 project in the parent directory.
		</p><p>
		Passing an argument (such as by dragging a file/directory onto the executable) has it load up the specified project.
		</p><p>
		Starting up from command-line/PowerShell/terminal allows to specify additional arguments: </p><ul>
			<li>	<code>--port &lt;port number&gt;</code>: Sets a custom port to run the server on.
				You shouldn't need to touch this unless the default port (5100) is being used by some other application or you desire to run multiple gmlive-server instances on multiple project directories at once.
			</li><li>	<code>--password &lt;string&gt;</code>: Sets a custom password (to be passed in <a href="#live_init">live_init</a>).
			</li><li>	<code>--timeout &lt;seconds&gt;</code>: Adjusts connection timeout for clients.
				In other words, how long it is without a response before a connection is dropped and related data structures are cleaned up. Default is 60 seconds and you wouldn't usually need to touch this unless you have issues with the game disconnecting during a step-by-step debug session.
			</li><li>	<code>--runtimePath &lt;path&gt;</code>: If your GMS2 runtimes somehow don't reside in the usual location and gmlive-server fails to detect them as result, you can use this to force a path (which would end on <code>\runtime-a.b.c.d</code>)
		</li></ul><p>
		On the technical side, gmlive-server is a <a href="http://nekovm.org/">Neko VM</a> application. For Windows, the few DLLs it uses and an executable version are packaged together with it. On Mac, you'll need to install Neko VM binaries (~1.5MB) to be able to run it from terminal via
		</p><pre>
neko gmlive-server.n
</pre></article></section><section><header id="tech-errors"><a href="#tech-errors" title="(permalink)">Error handling</a></header><article><p>
		Things that GMLive takes care of: </p><ul>
			<li>	Syntax errors in "live" code<br/>
				(code will not be updated if the new version doesn't compile)
			</li><li>	Value errors (e.g. trying to add a string to a number, dividing by 0)
			</li><li>	Missing variables/instances
			</li><li>	Wrong argument types passed to common built-in functions
		</li></ul><p>
		When a "runtime" error occurs, it is logged and the "live" script/event halts execution.
		This does not prevent subsequent attempts to execute the code.
		</p><p>
		Things that GMLive cannot take care of: </p><ul>
			<li>	Runtime errors in non-"live" scripts
			</li><li>	Fatal errors thrown by built-in functions (e.g. memory allocation errors)
		</li></ul><p>
		If you are using GMS1 or older versions of GMS2 (2.2.5 or earlier),
		you can also use <a href="https://yellowafterlife.itch.io/gamemaker-catch-error">catch_error</a>
		and a "GMLiveForGMSX_and_catch_error" version of the extension to prevent a number of crashes.
	</p></article></section><section><header id="multi-os"><a href="#multi-os" title="(permalink)">Using GMLive on Windows and Mac/Linux at once</a></header><article><p>
		If you have the same project directory shared between a Windows and non-Windows machine
		(via cloud sync, network folder, SyncThing, version control, etc.)
		and want to be able to use GMLive without adding/removing files,
		you can do any of the following: </p><ul>
		<li>	Make a copy of GMLive folder so that you have one for Windows (with EXE and NDLLs)
			and one for Mac/Linux (without NDLLs).
		</li><li>	If using Git, delete the NDLL files, commit the deletion,
			add them back on Windows machine, and also
			add them to <code>.gitignore</code> so that they do not make it to Mac/Linux machines.
		</li><li>	Install Neko VM on Windows so that you don't need the NDLLs nor the EXE
			(and subsequently run <code>neko gmlive-server.n</code> from Command Prompt/PowerShell)
		</li><li>	Copy the GMLive folder elsewhere and run it from Command Prompt/PowerShell/terminal
			with a path to your YYP (see <a href="#gmlive-server">above</a>).
		</li></ul></article></section></article></section><section><header id="Limitations"><a href="#Limitations" title="(permalink)">Limitations</a></header><article><a class="sticky-side" href="#Limitations" title="Limitations"><span>Limitations</span></a><section><header id="lim-performance"><a href="#lim-performance" title="(permalink)">Performance</a></header><article><p>
		On average, any time you add another layer on interpreted code, performance degrades 5x..10x
		- YYC code is on average 5 times slower than equivalent handwritten C++ code,
		non-YYC GML is about 3..5 times slower than that, and GMLive,
		<abbr title="to be able to access various structures that are not exposed to native extensions">having runtime compiled to GML</abbr>,
		has roughly GM8.1 level of performance on non-YYC and roughly regular GMS level of performance on YYC.
		</p><p>
		This has a few implications: </p><ul>
		<li>	Enabling livecoding for too many performance-critical scripts at once isn't a good idea.<br/>
			GMLive versions from 1.0.48 onward will not compile-interpret code until a script/event
			is changed after game start, but still there is minor overhead in checking whether the
			script/event has a "live" version loaded or not.
		</li><li>	Using GMLive for ad-hoc modding support isn't a super good idea
			</li><li> both for performance reasons and because the interpreted scripts would have
			complete access to GameMaker API and game's resources.<br/>
			You can look into <a href="https://github.com/YAL-GameMaker/tiny-expression-runtime">tiny expression runtime</a>
		</li></ul><p>
		That said, both GMLive and GameMaker are being worked on, thus things will likely improve as time goes on.
	</p></article></section><section><header id="lim-modding"><a href="#lim-modding" title="(permalink)">Use of GMLive for modding</a></header><article><p>
		Although it may be tempting to use GMLive's
		<code>live_execute_string</code> and <a href="#live_snippet_create">Snippet API</a>
		for ad-hoc modding support,
		the consequences of that aren't unlike use of <code>execute_string</code> -
		you would be executing code without any security measures in place,
		meaning that scripts could crash the game, corrupt save data or unrelated variables, and so on.
		</p><p>
		Better options would be: </p><ul>
		<li>	<a href="https://github.com/katsaii/catspeak-lang">catspeak</a><br/>
			An open-source scripting language and compiler backend for GameMaker.
			Pretty fancy.
		</li><li>	<a href="https://github.com/YAL-GameMaker/tiny-expression-runtime">tiny expression runtime</a><br/>
			An open-source example project and accompanying tutorial on writing purpose-specific
			scripting languages, by me.
		</li><li>	<a href="https://yellowafterlife.itch.io/gamemaker-lua">Apollo</a><br/>
			A native wrapper for industry-standard Lua, by me.<br/>
			Similarly has sandboxing and full control over what executed code can access.
		</li><li>	For projects with higher requirements,
			I may occasionally be available for contract work and have built
			<a href="https://yal.cc/works-ext/#Compiler">all kinds of compilers and interpreters</a>
			for clients over years.
		</li></ul></article></section><section><header id="lim-native-ext"><a href="#lim-native-ext" title="(permalink)">Calling functions in native extensions</a></header><article><p>
		GMLive by default has entirety of standard GameMaker API and all game-specific resources
		exposed to it, but native extensions' functions currently cannot be dynamically referenced,
		therefore you would not be able to call them from "live" code by default.
		</p><p>
		As a workaround, you can either
		make a script that calls the function, and then call that script,
		or use <a href="#live_function_add">live_function_add</a> to expose wrapped functions to GMLive, like so:
		</p><pre class="gmlmd">
<a class="sf" href="#live_function_add">live_function_add</a><span class="op">(</span><span class="st">"ext_func(a, b)"</span><span class="op">,</span> <span class="kw">function</span><span class="op">(</span><span class="lv">a</span><span class="op">,</span> <span class="lv">b</span><span class="op">)</span> <span class="cb">{</span>
    <span class="kw">return</span> <span class="uf">ext_func</span><span class="op">(</span><span class="lv">a</span><span class="op">,</span> <span class="lv">b</span><span class="op">)</span><span class="op">;</span>
<span class="cb">}</span><span class="op">)</span><span class="op">;</span>
</pre></article></section><section><header id="lim-array-copy"><a href="#lim-array-copy" title="(permalink)">Copy-on-write behaviour in arrays</a></header><article><p>
		<strong>NOTE:</strong> As of GM2022, copy-on-write has been deprecated and is turned off by default
		in new projects.
		</p><p>
		GML itself has a <a href="http://docs2.yoyogames.com/source/_build/3_scripting/3_gml_overview/10_arrays.html">particular feature</a>
		(see "Advanced Array Functionality") that has it so that passing an array as an argument
		to a script, and then changing it via <code>arr[index] = value</code>
		(rather than <code>arr[@index] = value</code>) would duplicate the array prior.
		</p><p>
		The internal data for this is not exposed, however,
		so GMLive is unable to do it in the same way,
		and only does "create-on-write" (replacing a value with a new array if it isn't yet).
		</p><p>
		If this doesn't make immediate sense, it is unlikely that you rely on this feature anywhere.
	</p></article></section><section><header id="lim-api"><a href="#lim-api" title="(permalink)">API compatibility</a></header><article><a class="sticky-side" href="#lim-api" title="API compatibility"><span>API compatibility</span></a><p>
		Since GMLive reasonably needs to reference every function and constant
		yet there is no way to go over constants nor get information about function arguments
		at runtime, so the extension has this massive script with function definitions and
		series of <a href="#live_function_add">live_function_add</a>/<a href="#live_variable_add">live_variable_add</a>/<a href="#live_constant_add">live_constant_add</a> calls.
		</p><p>
		Here are the specific cases and instructions for getting around them:
		</p><section><header>Function signature changes</header><article><p>
			As of GMS2022, GMLive will gracefully new functions appearing (albeit with no argument count checks)
			or functions going missing, but it cannot handle argument changes for existing functions -
			like the infamous reduction of <code>buffer_set_surface</code> from 5 to 3 arguments,
			or introduction of an optional argument to <code>instance_create_depth</code>.
			</p><p>
			When this happens, GMLive will refuse to compile code with seemingly-incorrect argument counts,
			but you can fix this yourself:
			
			</p><pre class="gmlmd">
<a class="sf" href="#live_function_add">live_function_add</a><span class="op">(</span><span class="st">"instance_create_depth(x, y, depth, object, ?vars)"</span><span class="op">,</span> <span class="sv">instance_create_depth</span><span class="op">)</span><span class="op">;</span>
</pre></article></section><section><header>Constants</header><article><p>
			If a GameMaker update adds new constants, "live" code will not be able to reference them
			until a GMLive update releases, but you can also handle this yourself, like so:
			</p><pre class="gmlmd">
<a class="sf" href="#live_constant_add">live_constant_add</a><span class="op">(</span><span class="st">"some_constant"</span><span class="op">,</span> <span class="uv">some_constant</span><span class="op">)</span><span class="op">;</span>
</pre><p>
			But if a constant is <i>removed</i>, you'll get a startup error in <code>GMLiveAPI</code>.<br/>
			You can comment out the offending lines in the script, but it can be easier to add
			an empty macro for each such constant, like so:
			</p><pre class="gmlmd">
<span class="md">#macro</span> <span class="uf">some_constant</span> <span class="sv">undefined</span>
</pre></article></section><section><header>Variables</header><article><p>
			On occasion, a GameMaker update might introduce a new global variable that
			"live" code wouldn't be aware of. You can fix this like so:
			</p><pre class="gmlmd">
<a class="sf" href="#live_variable_add">live_variable_add</a><span class="op">(</span><span class="st">"some_variable"</span><span class="op">,</span> <span class="kw">function</span><span class="op">(</span><span class="lv">set</span><span class="op">,</span> <span class="lv">val</span><span class="op">)</span> <span class="cb">{</span>
    <span class="kw">if</span> <span class="op">(</span><span class="lv">set</span><span class="op">)</span> <span class="cb">{</span>
        <span class="uv">some_variable</span> <span class="op">=</span> <span class="lv">val</span><span class="op">;</span>
    <span class="cb">}</span> <span class="kw">else</span> <span class="kw">return</span> <span class="uv">some_variable</span><span class="op">;</span>
<span class="cb">}</span><span class="op">)</span><span class="op">;</span>
</pre></article></section></article></section></article></section><section><header id="troubleshooting"><a href="#troubleshooting" title="(permalink)">Troubleshooting</a></header><article><a class="sticky-side" href="#troubleshooting" title="Troubleshooting"><span>Troubleshooting</span></a><section><header id="no-updates"><a href="#no-updates" title="(permalink)">Code does not update</a></header><article><ul>
		<li>	Make sure that you are saving the file (Ctrl+S or Cmd+S).
		</li><li>	Make sure that gmlive-server is running.
		</li><li>	Check the output log for any compile/runtime errors with new code.
		</li><li>	Check gmlive-server window for any project load errors.
		</li><li>	Check if the time next to the client in gmlive-server window is ticking.<br/>
			If it's not ticking, you likely accidentally deactivated/destroyed <code>obj_gmlive</code>.
		</li></ul></article></section><section><header id="error-arg-index"><a href="#error-arg-index" title="(permalink)">"Argument index is out of range"</a></header><article><p>
		This usually happens for one of two reasons: </p><ul>
		<li>	You are calling the script with fewer arguments than you have the code expect<br/>
			(in which case GM would throw you an error as well).
		</li><li>	You forgot to add script arguments to <a href="#live_call">live_call</a>/<a href="#live_call_ext">live_call_ext</a>.
		</li></ul></article></section><section><header id="error-no-func"><a href="#error-no-func" title="(permalink)">"Couldn't find live function"</a></header><article><p>
		There are generally two possible causes for this error:
		</p><ol>
		<li>	You are trying to live-code a function-in-function
			(e.g. a static function inside a constructor)
			or function-in-event
			(e.g. a function assigned inside a Create event).  <br/>
			Depending on GameMaker version,
			<code>debug_get_callstack()</code> output can be unreliable for such cases,
			so use of <a href="#live_name">live_name</a> is necessary for GMLive to know which function
			it should be taking the new code from.
		</li><li>	You are using a macro that has not been auto-detected as containing a live-call.  <br/>
			Try using one of the default <a href="[\_ext](live_call_ext)">live_call</a> functions instead.
		</li></ol></article></section><section><header id="error-inst-call"><a href="#error-inst-call" title="(permalink)">"Can't call instance-specific function - instance does not exist."</a></header><article><p>
		You can occasionally get this error in output log when calling scripts for instances
		after deactivating/destroying them - currently the only way <code>self</code>/<code>other</code>
		instances can be set up for a call is via <code>with</code> blocks,
		and these do not work with deactivated/destroyed instance IDs.
		</p><p>
		GMLive uses a few workarounds to get around this in common situations
		(applying to original <code>self</code>/<code>other</code> instances of the event), but if you have something like
		</p><pre class="gmlmd">
<span class="kw">with</span> <span class="op">(</span><span class="uv">some_instance_id</span><span class="op">)</span> <span class="cb">{</span>
    <span class="sf">instance_destroy</span><span class="op">(</span><span class="op">)</span><span class="op">;</span>
    <span class="uf">scr_some_instance_script</span><span class="op">(</span><span class="op">)</span><span class="op">;</span>
<span class="cb">}</span>
</pre><p>
		that may show that error.
		</p><p>
		As a workaround, you can either change your code not to attempt to call scripts on freshly
		deactivated/destroyed instances, or move the D/D+call branch into a separate script.
	</p></article></section><section><header id="error-tilemaps"><a href="#error-tilemaps" title="(permalink)">Problems with tilemaps in "live" rooms</a></header><article><p>
		If you are using <code>layer_tilemap_get_id</code>, you should be aware (as per manual) that it does not work
		with "dynamically" created tilemaps, including those made by GMLive.
		</p><p>
		The workaround is to make a little function that finds the tilemap on the layer,
		which might look as following:
		</p><pre class="gmlmd">
<span class="kw">function</span> <span class="uf">layer_tilemap_get_id_fixed</span><span class="op">(</span><span class="lv">_layer</span><span class="op">)</span> <span class="cb">{</span>
    <span class="kw">var</span> <span class="lv">els</span> <span class="op">=</span> <span class="uf">layer_get_all_elements</span><span class="op">(</span><span class="lv">_layer</span><span class="op">)</span><span class="op">;</span>
    <span class="kw">var</span> <span class="lv">n</span> <span class="op">=</span> <span class="sf">array_length_1d</span><span class="op">(</span><span class="lv">els</span><span class="op">)</span><span class="op">;</span>
    <span class="kw">for</span> <span class="op">(</span><span class="kw">var</span> <span class="lv">i</span> <span class="op">=</span> <span class="nu">0</span><span class="op">;</span> <span class="lv">i</span> <span class="op">&lt;</span> <span class="lv">n</span><span class="op">;</span> <span class="lv">i</span><span class="op">++</span><span class="op">)</span> <span class="cb">{</span>
        <span class="kw">var</span> <span class="lv">el</span> <span class="op">=</span> <span class="lv">els</span><span class="op">[</span><span class="lv">i</span><span class="op">]</span><span class="op">;</span>
        <span class="kw">if</span> <span class="op">(</span><span class="uf">layer_get_element_type</span><span class="op">(</span><span class="lv">el</span><span class="op">)</span> <span class="op">==</span> <span class="uv">layerelementtype_tilemap</span><span class="op">)</span> <span class="cb">{</span>
            <span class="kw">return</span> <span class="lv">el</span><span class="op">;</span>
        <span class="cb">}</span>
    <span class="cb">}</span>
    <span class="kw">return</span> <span class="op">-</span><span class="nu">1</span><span class="op">;</span>
<span class="cb">}</span>
</pre></article></section><section><header id="error-gmlive-copy"><a href="#error-gmlive-copy" title="(permalink)">What is "GMLive - copy.gml"?</a></header><article><p>
		Occasionally I make a copy of one or other GMLive script to run a text diff tool on them
		before publishing an update and forget to remove them later. Such files are safe to remove.
	</p></article></section><section><header id="error-mac-lib-load"><a href="#error-mac-lib-load" title="(permalink)">"Failed to load library : no suitable image found. "</a></header><article><p>
		You can get this on Mac if you did not remove the original <code>ndll</code> files
		- NDLLs that Windows uses are different from those for OSX.
	</p></article></section><section><header id="error-cleartext"><a href="#error-cleartext" title="(permalink)">"Cleartext HTTP traffic not permitted" on Android</a></header><article><p>
		You'll need to add
		</p><pre>
&lt;android:usesCleartextTraffic="true"&gt;
</pre><p>
		to "Game Options â Android â Permissions - Inject to Application Tag".
	</p></article></section><section><header id="error-debug-create"><a href="#error-debug-create" title="(permalink)">Running game in debug mode skips over create events</a></header><article><p>
		GameMaker versions prior to GMS2.3 have a curious bug that has it that
		if your game has "enough" code in it and your computer matches the unknown requirements,
		the debugger may choke for a bit, causing the game to skip events for the first few frames.
		</p><p>
		Since GMLive adds about 900KB worth of GML code to your game, it tends to tip off the issue for affected users.
		</p><p>
		The solution is to add a blank room in front of the rest, and add a blank object to it which has a step event with something like the following:
		</p><pre class="gmlmd">
<span class="kw">if</span> <span class="op">(</span><span class="op">!</span><span class="sv">debug_mode</span> <span class="op">||</span> <span class="op">++</span><span class="sv">x</span> <span class="op">&gt;</span> <span class="sv">xstart</span> <span class="op">+</span> <span class="nu">3</span><span class="op">)</span> <span class="cb">{</span>
    <span class="sf">instance_destroy</span><span class="op">(</span><span class="op">)</span><span class="op">;</span>
    <span class="sf">room_goto_next</span><span class="op">(</span><span class="op">)</span><span class="op">;</span> <span class="co">// or room_goto(real_init_room)</span>
<span class="cb">}</span>
</pre><p>
		In worse cases, <code>3</code> may be increased until the issue is no longer present.
		</p><p>
		The issue seems to be fixed as of GM2022.
	</p></article></section></article></section></p><!--doc>-->
</section></main></div>
<script type="text/javascript">(function() {
	var doc, headers;
	//
	var path = "GMLive.gml cheat sheet";
	var state = null;
	if (window.localStorage && JSON.parse) {
		state = window.localStorage.getItem(path);
		state = state ? JSON.parse(state) : { };
		if (state == null) state = { };
	}
	var isLocal = (location.host.indexOf("localhost") == 0);
	//
	function h3bind(h3) {
		var node = h3.parentNode;
		var snip = node.children[1];
		var id = h3.id || h3.textContent;
		h3.snip = snip;
		h3.doc_set = function(z) {
			if (z) node.classList.add("open"); else node.classList.remove("open");
			if (state) {
				state[id] = z;
				window.localStorage.setItem(path, JSON.stringify(state));
			}
		}
		h3.doc_hide = function() {
			this.doc_set(false);
		}
		h3.doc_show = function() {
			this.doc_set(true);
		}
		h3.onclick = function(_) {
			var seen = !node.classList.contains("open");
			h3.doc_set(seen);
			return false;
		};
	}
	function getHashFunc(id) {
		var node = document.getElementById(id);
		if (node == null) return null;
		return function(e) {
			while (node && node != doc) {
				if (node.classList.contains("item")) {
					node.classList.add("open");
				}
				node = node.parentElement;
			}
		};
	}
	// Display helpers:
	window.opt_none = function() {
		for (var li = 0; li < headers.length; li++) headers[li].doc_hide();
	};
	window.opt_list = function() {
		for (var li = 0; li < headers.length; li++) {
			var h3 = headers[li];
			if (h3.parentNode.parentNode != doc) {
				h3.doc_hide();
			} else h3.doc_show();
		}
	};
	window.opt_all = function() {
		for (var li = 0; li < headers.length; li++) headers[li].doc_show();
	};
	window.live_post = function() {
		doc = document.getElementById("doc");
		headers = doc.getElementsByTagName("header");
		//
		for (var i = 0; i < headers.length; i++) h3bind(headers[i]);
		// Clicks in document expand the related section:
		var anchors = doc.getElementsByTagName("a");
		for (var i = 0; i < anchors.length; i++) {
			var anchor = anchors[i];
			if (anchor.classList.contains("header")) continue;
			var href = anchor.getAttribute("href");
			if (href[0] == "#") {
				var fn = getHashFunc(href.substr(1));
				if (!fn) {
					anchor.classList.add("broken");
					anchor.title = "(section missing)";
				} else anchor.addEventListener("click", fn);
			}
		}
		//
		for (var li = 0; li < headers.length; li++) {
			var h3 = headers[li];
			var val = state ? state[h3.id || h3.textContent] : null;
			if (val == null) val = isLocal || h3.parentNode.parentNode == doc;
			if (val) h3.doc_show(); else h3.doc_hide();
		}
	};
	window.live_post();
	//
	(function() {
		var hash = document.location.hash;
		if (hash) {
			var _hash = hash.substr(1);
			getHashFunc(_hash)();
			setTimeout(function() {
				document.location.hash = hash + " ";
				setTimeout(function() {
					document.location.hash = hash;
				}, 100);
			}, 100);
		}
	})();
	//
	doc.setAttribute("ready", "");
	})();</script>
</body></html>
